
import random, re, math, time

ciphertext = """53‡‡†305))6*;4826)4‡.)4‡);806*;48†8¶60))85;;]8*;:‡*8†83
(88)5*†;46(;88*96*?;8)*‡(;485);5*†2:*‡(;4956*2(5*—4)8¶8*

;4069285);)6†8)4‡‡;1(‡9;48081;8:8‡1;48†85;4)485†528806*81 (‡9;48;(88;4(‡?34;48)4‡;161;:188;‡?;""".replace("\n"," ")

COMMON_WORDS = { "the","be","to","of","and","a","in","that","have","i","it","for","not","on","with","he","as","you","do","at",
"this","but","his","by","from","they","we","say","her","she","or","an","will","my","one","all","would","there","their",
"what","so","up","out","if","about","who","get","which","go","me","when","make","can","like","time","no","just",
"him","know","take","people","into","year","your","good","some","could","them","see","other","than","then","now",
"look","only","come","its","over","think","also","back","after","use","two","how","our","work","first","well",
"way","even","new","want","because","any","these","give","day","most","us" }

# prepare cipher symbols by frequency
cipher_counts = {}
for c in ciphertext:
    if c.isspace(): continue
    cipher_counts[c] = cipher_counts.get(c,0)+1
symbols_by_freq = sorted(cipher_counts.keys(), key=lambda k:-cipher_counts[k])
N = min(26, len(symbols_by_freq))
cipher_alphabet = symbols_by_freq[:N]

english_freq_order = list("etaoinshrdlcumwfgypbvkjxqz")

def initial_key():
    return {sym: english_freq_order[i] for i,sym in enumerate(cipher_alphabet)}

def decrypt_with_key(key):
    out = []
    for ch in ciphertext:
        if ch in key: out.append(key[ch])
        else:
            if ch.isdigit() or ch in ".,;:!?—()[]'\"/\\": out.append(ch)
            else: out.append('?')
    return "".join(out)

_word_re = re.compile(r"[a-zA-Z]+")
def score_plaintext(pt):
    words = _word_re.findall(pt.lower())
    if not words: return -9999
    score = 0.0
    for w in words:
        if w in COMMON_WORDS: score += len(w) * 2.0
        else:
            vowel_frac = sum(ch in "aeiou" for ch in w) / max(1,len(w))
            score += vowel_frac * 0.1
    for fn in (" the ", " and ", " that ", " be ", " to ", " of "):
        if fn in (" " + pt.lower() + " "): score += 5.0
    score -= pt.count('?') * 0.5
    return score

def random_neighbor(key):
    a,b = random.sample(cipher_alphabet,2)
    nk = key.copy()
    nk[a], nk[b] = nk[b], nk[a]
    return nk

def solve(max_restarts=200, iterations_per_restart=2500, time_limit=20.0):
    start_time = time.time()
    best_key = initial_key()
    best_plain = decrypt_with_key(best_key)
    best_score = score_plaintext(best_plain)
    for restart in range(max_restarts):
        if time.time() - start_time > time_limit: break
        if restart % 5 == 0:
            key = initial_key()
        else:
            letters = english_freq_order.copy()
            random.shuffle(letters)
            key = {sym: letters[i] for i,sym in enumerate(cipher_alphabet)}
        current_score = score_plaintext(decrypt_with_key(key))
        T0 = 1.0
        for it in range(iterations_per_restart):
            if time.time() - start_time > time_limit: break
            T = T0 * (1 - it/iterations_per_restart)
            nk = random_neighbor(key)
            pt = decrypt_with_key(nk)
            s = score_plaintext(pt)
            delta = s - current_score
            if delta > 0 or math.exp(delta / max(1e-6,T)) > random.random():
                key = nk; current_score = s
                if s > best_score:
                    best_score = s; best_key = key.copy(); best_plain = pt
    return best_plain, best_score, best_key

plaintext, sc, final_key = solve(max_restarts=200, iterations_per_restart=2500, time_limit=20.0)
print("\n=== Best candidate plaintext (score {:.2f}) ===\n".format(sc))
print(plaintext)
print("\n=== Key mapping (cipher symbol -> plaintext letter) ===")
for s in cipher_alphabet:
    print(repr(s), "->", final_key.get(s,'?'), "(count={})".format(cipher_counts.get(s,0)))
