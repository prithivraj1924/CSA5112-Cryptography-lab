import math

# Function to compute modular inverse
def mod_inverse(a, m):
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return None

# Decryption function
def affine_decrypt(ciphertext, a, b):
    a_inv = mod_inverse(a, 26)
    if a_inv is None:
        raise ValueError("Invalid 'a', no modular inverse exists.")
    
    plaintext = ""
    for char in ciphertext.upper():
        if char.isalpha():
            c = ord(char) - 65
            p = (a_inv * (c - b)) % 26
            plaintext += chr(p + 65)
        else:
            plaintext += char
    return plaintext

# Given frequency information:
# Most frequent ciphertext letter = 'B'
# Second most frequent ciphertext letter = 'U'
# Assume they map to plaintext 'E' and 'T'
C1, P1 = 1, 4    # B -> E
C2, P2 = 20, 19  # U -> T

# Solve for 'a' and 'b'
for a in range(1, 26):
    if math.gcd(a, 26) == 1:  # 'a' must be coprime with 26
        for b in range(26):
            if (a * P1 + b) % 26 == C1 and (a * P2 + b) % 26 == C2:
                print(f"Possible keys found: a = {a}, b = {b}")

# Verify the key (3,15)
ciphertext = input("\nEnter ciphertext to decrypt: ")
a, b = 3, 15
plaintext = affine_decrypt(ciphertext, a, b)

print(f"\nDecrypted using (a={a}, b={b}):")
print(plaintext)
