#!/usr/bin/env python3
"""
Caesar / additive cipher letter-frequency attack.
Tries all 26 shifts, scores candidates by Chi-squared against English letter frequencies,
and returns top-N candidates (best first). Interactive CLI.
"""

from collections import Counter
import math
import re

ENGLISH_FREQ = {
    'A': 8.167, 'B': 1.492, 'C': 2.782, 'D': 4.253, 'E': 12.702, 'F': 2.228,
    'G': 2.015, 'H': 6.094, 'I': 6.966, 'J': 0.153, 'K': 0.772, 'L': 4.025,
    'M': 2.406, 'N': 6.749, 'O': 7.507, 'P': 1.929, 'Q': 0.095, 'R': 5.987,
    'S': 6.327, 'T': 9.056, 'U': 2.758, 'V': 0.978, 'W': 2.361, 'X': 0.150,
    'Y': 1.974, 'Z': 0.074
}

ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def shift_text(text, shift):
    """Shift letters in text by `shift` (0-25). Non-letters are preserved.
       Output is uppercase for readability."""
    result = []
    for ch in text:
        if ch.isalpha():
            uc = ch.upper()
            shifted = chr((ord(uc) - ord('A') + shift) % 26 + ord('A'))
            result.append(shifted)
        else:
            result.append(ch)
    return ''.join(result)

def chi_squared_score(text):
    """Compute chi-squared statistic between text letter frequencies and ENGLISH_FREQ.
       Lower is better (closer to expected English)."""
    letters = [c for c in text.upper() if c.isalpha()]
    n = len(letters)
    if n == 0:
        return float('inf')
    counts = Counter(letters)
    score = 0.0
    for letter in ALPHABET:
        observed = counts.get(letter, 0)
        expected = ENGLISH_FREQ[letter] * n / 100.0
        # expected not zero with English table above
        score += ((observed - expected) ** 2) / expected
    return score

def attack_additive(ciphertext, top_n=10):
    """Try all 26 shifts and return top_n candidate plaintexts sorted by likelihood (best first)."""
    ciphertext = ciphertext.strip()
    candidates = []
    for shift in range(26):
        candidate = shift_text(ciphertext, shift)
        score = chi_squared_score(candidate)
        # small heuristic: count common short words (space-padded to avoid substrings)
        common_words = [" THE ", " AND ", " TO ", " OF ", " IS ", " THAT ", " IN "]
        boost = sum(candidate.count(w) for w in common_words)
        candidates.append((shift, candidate, score, boost))
    # sort by score ascending (better), then by boost descending
    candidates.sort(key=lambda x: (x[2], -x[3]))
    results = []
    for shift, candidate, score, boost in candidates[:top_n]:
        results.append({
            'shift': shift,
            'plaintext': candidate,
            'chi_squared': round(score, 2),
            'common_word_matches': int(boost)
        })
    return results

def print_candidates(candidates):
    print(f"{'Rank':>4}  {'Shift':>5}  {'Chi^2':>8}  {'Words':>5}  Plaintext")
    print("-" * 80)
    for i, c in enumerate(candidates, 1):
        pt = c['plaintext']
        display_pt = pt if len(pt) <= 64 else pt[:61] + "..."
        print(f"{i:>4}  {c['shift']:>5}  {c['chi_squared']:>8}  {c['common_word_matches']:>5}  {display_pt}")

def main():
    print("Additive (Caesar) cipher frequency attack")
    print("----------------------------------------")
    ciphertext = input("Enter ciphertext (paste and press Enter):\n").strip()
    if not ciphertext:
        print("No input provided. Exiting.")
        return
    try:
        top_n = int(input("How many top candidates to show? (default 10): ") or "10")
    except ValueError:
        top_n = 10
    print("\nComputing...\n")
    results = attack_additive(ciphertext, top_n=top_n)
    print_candidates(results)
    print("\nNotes: 'shift' is the amount applied to the ciphertext to produce the plaintext shown.")
    print("If you expect lowercase/punctuation preserved, the output is uppercase for easier reading.")

if __name__ == "__main__":
    main()
