from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

def pad_block(block, block_size=16):
    # Ensure block is exactly one AES block
    return block.ljust(block_size, b'\x00')

def cbc_mac(key, message, block_size=16):
    cipher = AES.new(key, AES.MODE_ECB)
    state = b'\x00' * block_size
    # Split message into blocks
    for i in range(0, len(message), block_size):
        block = message[i:i+block_size]
        state = cipher.encrypt(bytes([a ^ b for a, b in zip(state, block)]))
    return state

# --- Demo ---
key = get_random_bytes(16)

# One-block message X
X = pad_block(b"HELLOBLOCK")  # padded to 16 bytes
T = cbc_mac(key, X)
print("MAC(K, X) =", T.hex())

# Forged two-block message: X || (X ⊕ T)
X_xor_T = bytes([a ^ b for a, b in zip(X, T)])
forged_message = X + X_xor_T
T_forged = cbc_mac(key, forged_message)
print("MAC(K, X || (X ⊕ T)) =", T_forged.hex())

# Check equality
print("Forgery successful?", T == T_forged)
